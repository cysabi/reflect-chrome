{
  "version": 3,
  "sources": ["../../build/util.js", "../../build/storage.js", "../../build/popup.js"],
  "sourcesContent": ["// util.ts provides utility functions that can be reused in other modules\nexport function addMinutes(date, minutes) {\n    return new Date(date.getTime() + minutes * 60000);\n}\nexport function cleanDomain(urls, exact = false) {\n    // check to see if urls exist\n    if (urls[0] === undefined) {\n        // return empty if not\n        return '';\n    }\n    else {\n        // regex match for url\n        const activeURL = urls[0].match(exact ? /^[\\w]+:\\/{2}([^#?]+)/ : /^[\\w]+:\\/{2}([\\w\\.:-]+)/);\n        // no matching sites, return empty\n        if (activeURL == null) {\n            return '';\n        }\n        return activeURL[1];\n    }\n}\nexport function insertAfter(newNode, existingNode) {\n    existingNode.parentNode.insertBefore(newNode, existingNode.nextSibling);\n}\nexport function createDivFromHTML(htmlString) {\n    const newDiv = document.createElement('div');\n    newDiv.insertAdjacentHTML('beforeend', htmlString);\n    return newDiv;\n}\nexport function getElementFromForm(id) {\n    return document.getElementById(id);\n}\n", "// storage.ts provides a thin wrapper around the chrome storage api to make it easier to read/write from it\n// you can also find helper functions that read/write to chrome storage\nimport { addMinutes } from './util';\n// helper function to retrive chrome storage object\n// usage:\n//\n// getStorage(null).then(storage => {\n//     ...\n// })\nexport function getStorage() {\n    return new Promise((resolve, reject) => {\n        chrome.storage.sync.get(null, (storage) => {\n            if (chrome.runtime.lastError !== undefined) {\n                reject(chrome.runtime.lastError);\n            }\n            else {\n                resolve(storage);\n            }\n        });\n    });\n}\n// helper function to set fields in chrome storage\n// usage:\n//\n// getStorage({enableBlobs: false}).then(storage => {\n//     ...\n// })\nexport function setStorage(key) {\n    return new Promise((resolve, reject) => {\n        chrome.storage.sync.set(key, () => {\n            if (chrome.runtime.lastError !== undefined) {\n                reject(chrome.runtime.lastError);\n            }\n            else {\n                resolve();\n            }\n        });\n    });\n}\n// Add a single url to blocklist (does nothing if url is already in list)\nexport function addToBlocked(url, callback) {\n    getStorage().then((storage) => {\n        // url = cleanDomain([url]) === '' ? url : cleanDomain([url])\n        if (!storage.blockedSites.includes(url)) {\n            storage.blockedSites.push(url);\n            setStorage({ blockedSites: storage.blockedSites }).then(() => {\n                console.log(`${url} added to blocked sites`);\n                callback ? callback() : () => { };\n            });\n        }\n    });\n}\n// Remove single url from blocklist (does nothing if url is not in list)\nexport function removeFromBlocked(url) {\n    getStorage().then((storage) => {\n        let blockedSites = storage.blockedSites;\n        blockedSites = blockedSites.filter((e) => e !== url);\n        setStorage({ blockedSites: blockedSites }).then(() => {\n            console.log(`removed ${url} from blocked sites`);\n        });\n    });\n}\n// Add a single url to whitelist with associated whitelist duration\n// (replaces any existing entries)\nexport function addToWhitelist(url, minutes) {\n    getStorage().then((storage) => {\n        let whitelistedSites = storage.whitelistedSites;\n        let expiry = addMinutes(new Date(), minutes);\n        whitelistedSites[url] = expiry.toJSON();\n        setStorage({ whitelistedSites: whitelistedSites }).then(() => {\n            console.log(`${url} added to whitelisted sites`);\n        });\n    });\n}\nexport function logIntentToStorage(intentString, intentDate, url, accepted) {\n    getStorage().then((storage) => {\n        let intentList = storage.intentList;\n        // getting oldest date value from intent list map\n        let oldest_date = new Date();\n        for (const rawDate in intentList) {\n            const date = new Date(rawDate);\n            if (date < oldest_date) {\n                oldest_date = date;\n            }\n        }\n        // deleting oldest intent to keep intent count under limit\n        if (Object.keys(intentList).length > storage.numIntentEntries) {\n            console.log(`list full, popping ${oldest_date.toJSON()}`);\n            delete intentList[oldest_date.toJSON()];\n        }\n        // adding new intent and date to intent list\n        intentList[intentDate.toJSON()] = {\n            intent: intentString,\n            url: url,\n            accepted: accepted,\n        };\n        // saving intentList to chrome storage\n        setStorage({ intentList: intentList }).then(() => {\n            console.log(`logged intent \"${intentString}\"`);\n        });\n    });\n}\n", "import { getStorage } from './storage';\nimport { cleanDomain } from './util';\n// when popup is loaded, setup event listeners\ndocument.addEventListener('DOMContentLoaded', () => {\n    // setup listener for toggle\n    const toggleSwitch = document.querySelector('#reflect-toggle');\n    toggleSwitch.addEventListener('change', toggleState, false);\n    // get current state and set approriately\n    getStorage().then((storage) => {\n        // set toggle state to storage value\n        toggleSwitch.checked = storage.isEnabled;\n        setupBlockListener(storage.blockedSites);\n    });\n});\n// function to update background with current toggle state\nfunction toggleState(e) {\n    const port = chrome.runtime.connect({\n        name: 'toggleState',\n    });\n    port.postMessage({ state: e.target.checked });\n    port.disconnect();\n}\n// updates the popup button when blocked or unblocked\nfunction updateButton(unblock) {\n    document.getElementById('block').innerHTML = unblock ? 'block page.' : 'unblock page.';\n    document.getElementById('block').style.borderRadius = unblock ? '5px 0 0 5px' : '5px';\n    document.getElementById('dropdown').style.display = unblock ? 'block' : 'none';\n}\n// setup listener for what block button should do\nfunction setupBlockListener(blockedSites) {\n    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n        const urls = tabs.map((x) => x.url);\n        const domain = cleanDomain(urls);\n        const url = cleanDomain(urls, true);\n        // not on a page (probably new tab)\n        if (domain === '') {\n            document.getElementById('curDomain').textContent = 'none.';\n            return;\n        }\n        document.getElementById('curDomain').textContent = domain;\n        // initial popup button configuration\n        let exact = false;\n        if (blockedSites.includes(domain)) {\n            updateButton(false);\n        }\n        else if (blockedSites.includes(url)) {\n            updateButton(false);\n            exact = true;\n        }\n        //document.getElementById('block').innerHTML = getButtonText(domain, url, blockedSites)\n        document.getElementById('block').addEventListener('click', () => {\n            const port = chrome.runtime.connect({\n                name: 'blockFromPopup',\n            });\n            // toggle state text and update background script\n            const buttonText = document.getElementById('block').innerHTML;\n            if (buttonText === 'block page.') {\n                port.postMessage({ unblock: false, siteURL: domain });\n                updateButton(false);\n            }\n            else {\n                port.postMessage({ unblock: true, siteURL: exact ? url : domain });\n                updateButton(true);\n            }\n            // cleanup connection\n            port.disconnect();\n        });\n        document.getElementById('blockPath').addEventListener('click', () => {\n            const port = chrome.runtime.connect({\n                name: 'blockFromPopup',\n            });\n            // toggle state text and update background script\n            const buttonText = document.getElementById('block').innerHTML;\n            if (buttonText === 'block page.') {\n                port.postMessage({ unblock: false, siteURL: url });\n                updateButton(false);\n            }\n            // cleanup connection\n            port.disconnect();\n        });\n        document.getElementById('blockPath').style.display = 'none';\n        /* When the user clicks on the button,\n        toggle between hiding and showing the dropdown content */\n        document.getElementById('dropdown').addEventListener('click', () => {\n            const dropdown = document.getElementById('blockPath');\n            dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';\n        });\n        // Close the dropdown if the user clicks outside of it\n        window.onclick = function (event) {\n            const target = event.target;\n            if (!target.matches('#dropdown')) {\n                const dropdown = document.getElementById('blockPath');\n                dropdown.style.display = 'none';\n            }\n        };\n    });\n}\n"],
  "mappings": ";;AAIO,uBAAqB,cAAc;AAEtC,QAAI,KAAK,OAAO;AAEZ,aAAO;AAAA;AAIP,wBAAkB,KAAK,GAAG,MAAM,QAAQ,yBAAyB;AAEjE,UAAI,aAAa;AACb,eAAO;AAAA;AAEX,aAAO,UAAU;AAAA;AAAA;;;ACRlB;AACH,WAAO,IAAI,QAAQ,CAAC;AAChB,aAAO,QAAQ,KAAK,IAAI,MAAM;AAC1B,YAAI,OAAO,QAAQ,cAAc;AAC7B,iBAAO,OAAO,QAAQ;AAAA;AAGtB,kBAAQ;AAAA;AAAA;AAAA;AAAA;;;ACbxB,WAAS,iBAAiB,oBAAoB;AAE1C,UAAM,eAAe,SAAS,cAAc;AAC5C,iBAAa,iBAAiB,UAAU,aAAa;AAErD,iBAAa,KAAK;AAEd,mBAAa,UAAU,SAAQ;AAC/B,yBAAmB,SAAQ;AAAA;AAAA;AAInC;AACI,iBAAa,OAAO,QAAQ,QAAQ;AAAA,MAChC,MAAM;AAAA;AAEV,SAAK,YAAY,CAAE,OAAO,EAAE,OAAO;AACnC,SAAK;AAAA;AAGT;AACI,aAAS,eAAe,SAAS,YAAY,UAAU,gBAAgB;AACvE,aAAS,eAAe,SAAS,MAAM,eAAe,UAAU,gBAAgB;AAChF,aAAS,eAAe,YAAY,MAAM,UAAU,UAAU,UAAU;AAAA;AAG5E;AACI,WAAO,KAAK,MAAM,CAAE,QAAQ,MAAM,eAAe,OAAQ;AACrD,mBAAa,KAAK,IAAI,OAAO,EAAE;AAC/B,qBAAe,YAAY;AAC3B,kBAAY,YAAY,MAAM;AAE9B,UAAI,WAAW;AACX,iBAAS,eAAe,aAAa,cAAc;AACnD;AAAA;AAEJ,eAAS,eAAe,aAAa,cAAc;AAEnD,kBAAY;AACZ,UAAI,aAAa,SAAS;AACtB,qBAAa;AAAA,iBAER,aAAa,SAAS;AAC3B,qBAAa;AACb,gBAAQ;AAAA;AAGZ,eAAS,eAAe,SAAS,iBAAiB,SAAS;AACvD,qBAAa,OAAO,QAAQ,QAAQ;AAAA,UAChC,MAAM;AAAA;AAGV,2BAAmB,SAAS,eAAe,SAAS;AACpD,YAAI,eAAe;AACf,eAAK,YAAY,CAAE,SAAS,OAAO,SAAS;AAC5C,uBAAa;AAAA;AAGb,eAAK,YAAY,CAAE,SAAS,MAAM,SAAS,QAAQ,MAAM;AACzD,uBAAa;AAAA;AAGjB,aAAK;AAAA;AAET,eAAS,eAAe,aAAa,iBAAiB,SAAS;AAC3D,qBAAa,OAAO,QAAQ,QAAQ;AAAA,UAChC,MAAM;AAAA;AAGV,2BAAmB,SAAS,eAAe,SAAS;AACpD,YAAI,eAAe;AACf,eAAK,YAAY,CAAE,SAAS,OAAO,SAAS;AAC5C,uBAAa;AAAA;AAGjB,aAAK;AAAA;AAET,eAAS,eAAe,aAAa,MAAM,UAAU;AAGrD,eAAS,eAAe,YAAY,iBAAiB,SAAS;AAC1D,yBAAiB,SAAS,eAAe;AACzC,iBAAS,MAAM,UAAU,SAAS,MAAM,YAAY,SAAS,UAAU;AAAA;AAG3E,aAAO,UAAU;AACb,uBAAe,MAAM;AACrB,YAAI,CAAC,OAAO,QAAQ;AAChB,2BAAiB,SAAS,eAAe;AACzC,mBAAS,MAAM,UAAU;AAAA;AAAA;AAAA;AAAA;",
  "names": []
}
